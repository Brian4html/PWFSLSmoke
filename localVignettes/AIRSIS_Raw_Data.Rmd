---
title: "AIRSIS Raw Data"
author: "Mazama Science"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{AIRSIS Raw Data}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, echo=FALSE}
knitr::opts_chunk$set(fig.width=7, fig.height=5)
```

This vignette explores how the PWFSLSmoke package can be leveraged to enable retrieval and exploration of raw ambient air quality data from multiple types of AIRSIS monitoring stations. We share examples using real monitoring data to support a variety of sample user tasks and questions.

This vignette focuses on monitors whose data is made available through AIRSIS; however, note that most if not all of the examples herein would also support exploration of raw data made available through WRCC for which similar functionality exists, e.g. `wrcc_createRawDataframe()`.

## Package Setup

\textcolor{red}{NOTE: This is all mentioned in the readme on the github page -- may be able to just point folks there for installation and setup.}

First things first, we need to load the PWFSLSmoke package and set up logging. You can pass
arguments to the `logger.setup()` function to send logging information to log files. In the following
example we use `logger.setLevel()` to send any ERROR output to the console.

```{r General Setup, message=FALSE}
library(PWFSLSmoke)
logger.setup()
logger.setLevel(ERROR)
```

We'll also need to load MazamaSpatialUtils, which can be done with the code below.

```{r MazamaSpatialUtils}
library(MazamaSpatialUtils)
setSpatialDataDir('~/Data/Spatial')
loadSpatialData('NaturalEarthAdm1')
```

If the previous code above gives an error, you may need to download Mazama spatial data files. To do so, enter the following in the command line:

```{bash eval=FALSE}
mkdir ~/Data
cd ~/Data
curl -OL http://smoke.airfire.org/RData/Spatial.tar.gz
tar -xzf Spatial.tar.gz
rm Spatial.tar.gz
```

If you are still having trouble setting things up, refer to the full package documentation and README at the following link: https://github.com/MazamaScience/PWFSLSmoke

## Data Acquisition

The first step in any data exploration is data acquisition. We'll use the `airsis_createRawDataframe()` function for this task.

The `airsis_createRawDataframe()` function creates a dataframe of raw monitoring data from a single monitor over a specific time period. For example, below we retrieve data from September 1 through October 15, 2016 for monitor IDs 1033 and 1049. Both monitors' data is provided by the U.S. Forest Service.

```{r airsis_createRawDataframe}
plain_AIRSIS_EBAM <- airsis_createRawDataframe(20160901,20161015,provider = 'USFS', unitID = 1033)
nile_AIRSIS_ESAM <- airsis_createRawDataframe(20160901,20161015,provider = 'USFS', unitID = 1049)
```

For reference, the following is a non-exhaustive list of monitors that can be called by the `airsis_createRawDataframe()` function as shown above. The data for all the monitors below is provided by U.S. Forest Service; others may be provided by APCD.

Monitor ID  | Location (Alias)   | Type
----------- | --------------- | ----------
1012 | Kettle Falls, WA (Fish Hatchery) | EBAM
1013 | Manson, WA (Kenned Meadows) | EBAM
1031 | Liberty, WA | EBAM
1033 | Plain, WA | EBAM
1034 | Curlew, WA | EBAM
1049 | Nile/Pinecliff, WA | E-Sampler
1050 | Kettle Falls, WA | E-Sampler

Note that in our example above we have pulled data for two different monitor types: the Plain monitor is an EBAM monitor, whereas the Nile/Pinecliff monitor is an E-Sampler. We'll explore the differences in data structures between the two monitor types a bit later on.

The `airsis_createRawDataframe()` function is nearly identical to the `airsis_createMonitorObject()` function, which is explained in depth in the \textcolor{red}{TODO: UPDATE NAME} vignette within this package. The process is briefly summarized below.

* **Data retrieval:** the `airsis_downloadData()` function downloads data from the specified provider for the monitor and time period requested. The data is brought into R as a single, long text string with comma separators and end-line characters (e.g. \\r\\n).
* **Parsing:** the `airsis_parseData()` function converts the long text string into a dataframe.
* **Quality Control:** the `airsis_qualityControl()` function performs some basic data cleaning and integrity checks. A uniform UTC timestamp field -- called 'datetime' -- is added, with data assigned to unique hours and duplicates removed as needed. 
* **Clustering:** the `addClustering()` function identifies unique deployments and assigns a single monitor ID, a latitude and a longitude, to each deployment. Unique deployments are identified using k-means clustering based on the cluster diameter passed to the `addClustering()` function through the `airsis_createRawDataframe()` function.

Up to this point this is the exact same process that the `airsis_createMonitorObject()` function uses to create a ws_monitor object. However, the processes deviate at the end with respect to what data is retained, and how it is stored. Specifically:

* the `airsis_createRawDataframe()` function retains all monitored data (including engineering data), whereas the ws_monitor object retains only the meta data and the time-stamped PM2.5 data.
* the `airsis_createRawDataframe()` function stores all meta and monitoring data in a single flat dataframe, whereas the ws_monitor object separates the meta data from the monitoing data to comply with the PWFSLSmoke ws_monitor class structure.

The end result of the `airsis_createRawDataframe()` function is a single dataframe with time-stamped meta, monitoring, and engineering data.

## Data Handling

Before we can begin to explore our data we should ensure that it adheres to a consistent and expected format regardless of the source, otherwise we could need complicated data handling procedures in all of our downstream applications.

Returning to our example data from above, we created two datasets from different sources, so naturally we expect that there may be some differences between them. Let's take a look at what fields exist in the raw dataframes for each monitor type.

```{r All Attribute Sets}
names(plain_AIRSIS_EBAM)
names(nile_AIRSIS_ESAM)
```

It is difficult to compare these large sets against one another; at a glance the fields don't appear to match up one-for-one, but this isn't necessarily a problem if the sets are identical but simply out of order from one another. However, we observe that the vectors have different lengths, so there must be at least some mismatch between the two. Careful inspection -- or better, a few simple lines of code -- allows for a quick evaluation of which fields are or are not shared between the two. First let's check which fields are shared between the types:

```{r Shared Attribute Sets}
names(plain_AIRSIS_EBAM)[names(plain_AIRSIS_EBAM) %in% names(nile_AIRSIS_ESAM)]
```

Just a little more than a dozen fields are shared, of which nearly half were created by the Quality Control process itself (i.e. "monitorName","monitorType","datetime","deploymentID","mediodLon","mediodLat").

Now we'll check which fields are in the EBAM data but not the E-Sampler data.

```{r EBAM-Unique Attributes}
names(plain_AIRSIS_EBAM)[!(names(plain_AIRSIS_EBAM) %in% names(nile_AIRSIS_ESAM))]
```

And, for completeness, we'll check the other direction as well.

```{r E-Sampler-Unique Attributes}
names(nile_AIRSIS_ESAM)[!(names(nile_AIRSIS_ESAM) %in% names(plain_AIRSIS_EBAM))]
```

From the latter two sets we can see that most of the differences in fields between the two monitor types appear to simply come down to naming conventions. For example, both monitor types include data on concentration (e.g. "COncRT" and "Conc.mg.m3"), flow ("Flow" and "Flow.l.m"), air temperature ("AT" and "AT.C"), as well as several other parameters. However, we need to be careful about units of measure. Even if we had a perfect match of field names it would be unreasonable to simply assume that two different monitor types output data in the same units of measure.

Additionally, we have some fields that appear in one set, but not the other. For example, we see FT (filter temperature) in the EBAM fields, but no such parameter presents itself in the E-Sampler fields. Indeed, no such parameter exists for E-Samplers because, unlike EBAM monitors, E-Samplers do not use filters to monitor PM~2.5~ (see brief overview of sampling techniques for the two monitors, and others, [here](https://app.airsis.com/USFS/About/MonitoringSystems)). Regardless, an engineer may be interested in plotting filter temperature for an EBAM monitor, so our raw data structure needs to allow for such analysis.

All this inconsistency calls for some form of harmonization to allow for simple and elegant use and exploration of the data, independent of its source. For this, we turn to the `raw_enhance()` function.

## Raw Enhance

The `raw_enhance()` function accepts a raw dataframe from any of a variety of types/sources and standardizes the data for downsteam data exploration. Specifically, the function ensures that the enhanced raw dataframe includes <u>_at least_</u> the following fields:

* **datetime:** unique 1-hour time stamps ($UTC$)
* **temperature:** air temperature ($^\circ$C)
* **humidity:** relative humidity ($\%$)
* **windSpeed:** wind speed ($m/s$)
* **windDir:** wind direction ($degrees$)
* **pm25:** PM~2.5~ concentration ($\mu g/m^3$)
* **longitude:** longitude ($degrees$)
* **latitude:** latitude ($degrees$)
* **pressure:** atmospheric pressure ($hPa$)
* **dataSource:** data source (e.g. 'AIRSIS')
* **timezone:** time zone (e.g. 'America/Los_Angeles')

You might notice that some of the fields above were already present in our raw dataframes before we ran them through the `raw_enhance()` function, albeit with perhaps slightly different names (e.g. <u>L</u>atitude vs. <u>l</u>atitude). You might also notice that some fields (e.g. filter temperature) are not included in the list above. Both of these observations are related and highlight two critical aspects of how the `raw_enhance()` function works to ensure maximum utility of our enhanced raw dataframes. Specifically, the function:

* Guarantees that the fields listed above will be present in all enhanced raw dataframes, with the exact names as shown above. The benefit of this consistency is two-fold:
    + It ensures the functionality of all downstream `rawPlot_*()` functions that depend on an enhanced raw dataframe with exact names as listed above.
    + It frees the analyst from the burden of having to remember the exact name of each parameter for each specific monitor/source type, in which there are often subtle differences. For example, wind direction is "W.D" for EBAMs and "WD.Deg." for E-Samplers; with the `raw_enhance()` output the analyst only needs to remember (or refer to this vignette) the small set of guaranteed names listed above -- in this case 'windDir' would be the parameter of interest.
* Maintains all raw data. Unlike the ws_monitor object, which reduces the dataset to meta data and time-stamped PM2.5 data, the `raw_enhance()` function returns a dataframe that retains <u>_all_</u> of the original raw data, plus additional data that has been set to the guaranteed names and units of measure as specified above. This allows the analyst to refer to the enhanced raw dataframe not only for the guaranteed names listed above, but for original and/or additional parameters as he or she so pleases. For example, filter temperature is only available for EBAM monitors so we have not included it as one of the guaranteed parameters; however, should an analyst be working with EBAM data, the filter temperature data would be available for reference if he or she so pleased.

A few caveats:

* A guaranteed parameter is simply guaranteed to exist; there is no guarantee that it will necessarily contain data. For example, atmospheric pressure is included as a guaranteed parameter since it is a key indicator of ambient conditions; however, EBAM monitors do not report pressure. Users will find pressure field populated with NAs for EBAM monitors. Missing data for any monitor type (e.g. due to sensor failure) would result in a similar situation.
* The framework above does result in quite a bit of redundancy; however, we have not found raw dataframe size to be large enough for this to matter. Thus, any grief with such redundancy is a matter of principle only, and should be far outweighed by the flexibility the framework allows for end users to quickly and easily access both standard and engineering parameters for on-the-fly analysis.

The end result of the `raw_enhance()` function is a robust framework which enables rapid exploration of data regardless of its original source.

To continue our prior examples, let's create enhanced raw dataframes for the two monitors from our earlier example:

```{r raw_enhance}
plain_enhanced <- raw_enhance(plain_AIRSIS_EBAM,rawSource='AIRSIS')
nile_enhanced <- raw_enhance(nile_AIRSIS_ESAM,rawSource='AIRSIS')
```

For demonstration purposes, we'll show the common parameters between the two dataframes now that they have been ehnaced.

```{r Shared Attribute Sets Enhanced}
names(plain_enhanced)[names(plain_enhanced) %in% names(nile_enhanced)]
```

Now that we have enhanced raw data dataframes we are ready to begin the data exploratin process!

## Data Exploration

### rawPlot_timeseries

Most likely the first thing we'll want to see once we have our data is a time series plot of one or more parameters. Do do this, we use the aptly-named rawPlot_timeseries function.

```{r}
rawPlot_timeseries(plain_enhanced)
```


### rawPlot_timeOfDaySpaghetti

```{r}
rawPlot_timeOfDaySpaghetti(plain_enhanced)
```


### rawPlot_pollutionRose

```{r}
rawPlot_pollutionRose(plain_enhanced)
```


### rawPlot_windRose

```{r}
rawPlot_windRose(plain_enhanced)
```



## Conclusion

R is powerful. We have developed solid tools. Lots of good stuff we can do now.

The end.
















## EXTRA STUFF -- Pull from below for sections above


After the PWFSLSmoke and the packages it depends upon are loaded, we can gather some monitoring data to work with.




A ws_monitor object is the basis for the entire PWFSLSmoke package. Simply put, a ws_monitor object is a data structure that the PWFSLSmoke package depends upon for its many functions to work properly. It consists of a few constraints:

* Constraint 1
* Constrains 2

To create a ws_monitor object, we call one of the "createMonitorObject" functions like the one shown below. See the "E-Sampler_Data_Handling" Vignette for a detailed look at what goes on in the function shown below, including download, parsing, QA/QC and clustering of the data.



We can use a variety of functions to manipulate ws_monitor objects. The monitor_subset function can also be used to pull out one or more monitors from a multi-monitor ws_monitor object (recall that ws_monitor objects can contain data for more than one monitor). Below, we'll use the monitor_subset() function to subset our data above over a specific time period. 

```{r}
#plain <- monitor_subset(plain_AIRSIS_EBAM,tlim = c(20160905,20160930))
```



```{r}
#monitorPlot_rollingMean(plain)
```

The steps above (to be expanded) can be used to create a ws_monitor object that conforms to internal data format standards which enables the use of tools developed specifically to handle such objecs. See _____ for more informtion on the ws_monitor data structure.

We can also create a raw dataframe. This process is similar.

```{r raw}
#df <- PWFSLSmoke::airsis_createRawDataframe(20160901, 20161015, provider='USFS', unitID=1033)
```

Now to clean the data


Now you have a nice raw dataset with which to work.



Make a plot

```{r}
#rawPlot_windRose(df,ws.int=1)
```



STRUCTURE:
 - Setup
 - ws_monitor object creation
 - ws_monitor plots and other goodies
 - raw_enhance object creation
 - raw_enhance plots and other goodies

## Put it all together
 
 Make a bunch of plots that are all related?
 
